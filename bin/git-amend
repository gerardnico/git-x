#!/bin/bash
# @name git-amend
# @description
# Simple way to add actual files to the last commit
#
# Reset the last commit (delete it and put the files in the index)
# Recreate a commit with all files
#
# If the last commit is tagged or have a release, it will ask
#
# ## SYNOPSIS
# ```bash
# git-amend
# ```
#
# ## TIP
#
# You can add it as alias in your `~.gitconfig`
# ```ini
# [alias]
#    am = "!git-amend"
# ```
#

set -Eeuo pipefail
# shellcheck source=../..//bash-lib/lib/bashlib-error.sh
source "${BASHLIB_LIBRARY_PATH:-}${BASHLIB_LIBRARY_PATH:+/}bashlib-error.sh"
error::set_trap
# shellcheck source=../..//bash-lib/lib/bashlib-doc.sh
source "${BASHLIB_LIBRARY_PATH:-}${BASHLIB_LIBRARY_PATH:+/}bashlib-doc.sh"
# shellcheck source=../..//bash-lib/lib/bashlib-string.sh
source "${BASHLIB_LIBRARY_PATH:-}${BASHLIB_LIBRARY_PATH:+/}bashlib-command.sh"
# shellcheck source=../..//bash-lib/lib/bashlib-git.sh
source "${BASHLIB_LIBRARY_PATH:-}${BASHLIB_LIBRARY_PATH:+/}bashlib-git.sh"

function synopsis(){

  cat <<EOF
\`\`\`bash
Add files to the last commit
$(basename "$0")  [Commit Message]
\`\`\`
If the commit message is not given, it will take the message of the last commit.
EOF

}

# Doc Synopsis
if [ "${1:-}" = "synopsis" ]; then
  synopsis
  exit 0
fi

# Help
if [[ "${1:-}" =~ -h|--help|help ]]; then
  doc::help synopsis
  exit 0
fi


# First submodule
if [ ! -f .git ]; then
  # Not in a submodule (or not in a git repo)
  git submodule foreach 'git-amend'
fi

if ! git::is_dirty_index ; then
  echo::warn "Nothing to amend"
  exit
fi

# Get the last commit hash
# Get the last commit hash
last_commit=$(git rev-parse HEAD)
tags=$(git tag --points-at "$last_commit")
if [ "$tags" != "" ]; then
    echo "Tags found on the last commit, deleting them"
    git-tag-delete "$tags"
fi



MESSAGE=${1:-};
if [ "$MESSAGE" == "" ]; then
  MESSAGE=$(git log -1 --pretty=%B)
fi
# Check the actual files before the undo (delete of the last commit)
# If there is an error in the actual files, the commit command will fail
# and the user don't know where he is (ie is the commit deleted ???)
# With this check, the user can run this command until no error occurs and be sure that
# there was only one undo
# By checking the file first, git-backup will not fail
# knowing that it will not delete another commit
command::echo_eval "git-prepare"
# delete the last commit
git-undo
# commit after / no verify to disable git-hooks has we have done it earlier with git-prepare
command::echo_eval "git commit --no-verify -am \"$MESSAGE\""
# push
command::echo_eval "git push"
