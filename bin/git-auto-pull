#!/bin/bash
# @name git-auto-pull
# @description
# Integrate the changes from an upstream
# (Stash if needed and pull)
# AutoStash with all pull type
#
# ## SYNOPSIS
# ```bash
# git auto-pull
# ```
# AutoPull to stay in the same fashion than AutoCommit
# ## TIP
#
# You can add it as alias in your `~.gitconfig`
# Example with `sp` that stands for `stash, pull`
# ```ini
# [alias]
#    sp = "!git-auto-pull"
# ```
#
# ## Note on Rebase AutoStash
#
# Pull has also a [rebase autostash option](https://git-scm.com/docs/git-pull/2.17.0#Documentation/git-pull.txt---autostash)
# ```bash
# git pull --rebase --autostash
# ```
# This script does not care the type of change integration, it works also with a `merge`
#
# You can automate a `git pull --rebase --autostash` via configuration.
# ```bash
# git config [--global] pull.rebase true
# git config [--global] rebase.autoStash true
# ```
#

set -Eeuo pipefail
source bashlib-error.sh
error::set_trap
source bashlib-git.sh
source bashlib-echo.sh
source bashlib-path.sh

DIRECTORY_NAME=$(path::get_current_directory_name)

# Stash before a merge to integrate the remote changes
# To avoid the error: Please commit your changes or stash them before you merge.
#
# Note that when the local changes do not conflict with the changes in the upstream,
# a simple git pull let you move forward but how do we know that ?
#
STASH=0
if git::is_dirty; then
  echo::info "$DIRECTORY_NAME - Working area dirty"
  STASH=1
else
  echo::info "$DIRECTORY_NAME - Working area not dirty"
fi

if [ "$STASH" = "1" ]; then
  echo::info "$DIRECTORY_NAME - Stashing the files $(git::get_dirty_files)"
  git stash
fi

echo::info "$DIRECTORY_NAME - Pulling"
git pull

if [ "$STASH" = "1" ]; then
  echo::info "$DIRECTORY_NAME - UnStashing"
  git stash pop # do a merge
fi
